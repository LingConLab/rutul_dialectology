---
title: Presence of exclusive-inclusive distinction
author: Ilya Sadakov
date: 'Last update: `r lubridate::make_datetime(year = 2024, month = 1, day = 11)`'
output:
  html_document:
    number_sections: false
    anchor_sections: true
    pandoc_args: --shift-heading-level-by=-1
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning=FALSE, fig.width = 9.5)
library(tidyverse)
library(lingtypology)
read_csv('data/database.csv', show_col_types = FALSE) |> 
  filter(feature_id == 57) ->
  db
read_csv('data/villages.csv') |> 
  filter(!(village %in% c('Kazankulak', 'Novyy Borch', 'Vrush', 'Aran', 'Khnyukh'))) ->
  villages
  
villages |> 
  filter(!(village %in% c('Tsudik', 'Borch'))) ->
  villages4map
  
```

The map shows the presence of distinction between the inclusive and first person exclusive pronouns. The distinction is PRESENT in Khnov where two different pronouns are distinguished: inclusive jinewi vs. exclusive juɢuˁmbɨ. The distinction is OPTIONAL in Kufa, Rutul and partly in Kiche (in one of two responses). The distinction there implies that the first person exclusive pronoun je may be opposed to the juxtaposition of first person exclusive with second person singular pronouns — je wɨ ‘we you’ — which expresses the inclusive meaning. In our data this distinction is optional, i.e. je could be used in place of je wɨ. Please note that our data for Ikhrek is not sufficient. In one of two responses two different lexemes were used in opposing contexts: ži in inclusive and ji in exclusive. However, Ibragimov (2004: 180 – 181) mentions that these two lexemes have lost the semantic exclusive - inclusive distinction, which actually was the opposite to the one shown in our response: inclusive ji vs. exclusive ži. According to Ibragimov (ibid.), currently two lexemes are equivalent, though ži is used more frequently, which is exemplified by another our response from Ikhrek where ži is used in both contexts. As in Ikhrek we did not manage to check carefully whether the lexemes ji and ži are interchangeable, or they form a semantic opposition, we consider the data collected there insufficient.


## {.tabset .tabset-fade .tabset-pills}

### Map

```{r}
db |> 
  filter(!is.na(value),
         value != 'NO DATA') |>
  mutate(value = str_split(value, ' ; ')) |> 
  unnest_longer(value) |> 
  distinct(settlement, value) |> 
  mutate(n = 1) |> 
  pivot_wider(names_from = value, values_from = n, values_fill = 0) |> 
  left_join(villages[,c('village', 'lat', 'lon')], c('settlement' = 'village')) |> 
  mutate(language = 'Rutul') ->
  for_map
  
if(length(for_map) == 5){
map.feature(languages = 'Rutul',
            latitude = villages4map$lat,
            longitude = villages4map$lon,
            label = villages4map$village,
            label.position = 'top',
            label.hide = FALSE,
            width = 10,
            color = 'gray',
            tile = 'OpenStreetMap.HOT',
            opacity = 0.4) |> 
  map.feature(languages = for_map$language,
              latitude = for_map$lat,
              longitude = for_map$lon,
              label = for_map$settlement,
              label.position = 'top',
              label.hide = FALSE,
              width = 10,
              tile = 'OpenStreetMap.HOT',
              features = colnames(for_map)[2],
              pipe.data = _)  
} else {
map.feature(languages = 'Rutul',
            latitude = villages4map$lat,
            longitude = villages4map$lon,
            label = villages4map$village,
            label.position = 'top',
            label.hide = FALSE,
            width = 10,
            color = 'gray',
            tile = 'OpenStreetMap.HOT',
            opacity = 0.4) |> 
  map.feature(languages = for_map$language,
            latitude = for_map$lat,
            longitude = for_map$lon,
            minichart.data = for_map |> select(-settlement, -lat, -lon, -language),
            minichart = 'pie', 
            width = 3,
            tile = 'OpenStreetMap.HOT',
            pipe.data = _)
}
```

### Data

```{r}
db |> 
  select(settlement, value, stimuli, answer, collected) |> 
  DT::datatable(class = 'cell-border stripe', 
    rownames = FALSE, 
    filter = 'top', 
    extensions = 'Buttons',
    options = list(pageLength = 42, 
                   autoWidth = TRUE, 
                   info = FALSE,
                   dom = 'fBltp',
                   buttons = list(list(extend = 'collection',
                                       buttons = c('csv', 'excel', 'pdf'),
                                       text = '<i class="fas fa-download"></i>')),
                   paginate = TRUE))
```


