---
title: "Change of a to o before w"
author: "Nikita Beklemishev"
date: 2025-08-28
format: html
lang: ru
css: styles.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 9.5)
```

In a simple rule, some dialects are expected to have an a > o / \_w phonetic alternation or sound change. By this rule, /a/ is rounded before a voiced labial approximant (or whatever its realisation is in a given utterance). In practice, we diagnose this by asking for cognates of two inter-dialectal lexemes: /ɢaw/ ‘ceiling’ and /awʁu/ ‘poison’. For a number of dialects we also asked for the words /awči/ ‘hunter’ and /sawχura/ ‘sleeps(III, PRS)’ (as in ‘The cow is sleeping’). The sounds in check (preliminary values) are the vowels in the first syllable before /w/. In this feature, ɨ and ə values of the correspondent vowel in these words are considered, because it is a frequent correspondence, even though it doesn’t fall under the generalization of presence or absence of the a > o change. Final values are a, o and oː (from monophtongisation of ow), ɨ / ə (as non-low mid vowels), OTHER (when the cognate wasn’t attested or when it was attested, but with aː / äw / a, bleeding the a > o change).


## ‘<III>sleep=PRS’ /sawχur a/

::: {.panel-tabset}

### Карта

```{r}
# Load data for this lexeme
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(lingtypology)

# Read the database and villages data
db <- read_csv("../data/database.csv", show_col_types = FALSE)
villages <- read_csv("../data/villages.csv", show_col_types = FALSE)

# Filter villages like in original script (exclude certain villages)
villages4map <- villages |>
  filter(!(village %in% c("Kazankulak", "Novyy Borch", "Vrush", "Aran", "Khnyukh")))

# Create mapping data for this lexeme
lexeme_data <- db |>
  filter(feature_id == 56) |>  # First filter by feature_id
  filter(feature_lexeme == "‘<III>sleep=PRS’ /sawχur a/") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {
  # Create mapping data for this lexeme
  mapping_data <- lexeme_data |>
    mutate(value = str_split(value, " ; ")) |>
    unnest_longer(value) |>
    distinct(settlement, value) |>
    mutate(n = 1) |>
    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>
    left_join(villages4map[,c("village","lat","lon")], by = c("settlement" = "village")) |>
    mutate(language = "Rutul") |>
    filter(!is.na(lat) & !is.na(lon))

  if (nrow(mapping_data) > 0) {
    # Convert feature columns to numeric
    feature_cols <- setdiff(colnames(mapping_data), c("settlement","lat","lon","language"))
    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))

    # Create sophisticated mapping approach with ALWAYS visible village names
    if(length(feature_cols) == 1){
      # single feature column - show all villages in gray, feature data in color
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)

      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE,
                                width = 10,
                                tile = "OpenStreetMap.HOT",
                                features = feature_cols)

      # Show both maps
      base_map
      feature_map
    } else {
      # multiple feature columns - use pie charts with ALWAYS visible village names
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)

      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                minichart.data = mapping_data |> select(all_of(feature_cols)),
                                minichart = "pie",
                                width = 3,
                                tile = "OpenStreetMap.HOT",
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE)

      # Show both maps
      base_map
      feature_map
    }
  } else {
    cat("Географические координаты недоступны для картографирования.\n")
  }
} else {
  cat("Данные для этой лексемы недоступны или координаты деревень не найдены.\n")
}
```

### Данные

```{r}
# Load required libraries
library(readr)
library(dplyr)
library(DT)

# Read the database data
db <- read_csv("../data/database.csv", show_col_types = FALSE)

# Create interactive table for this lexeme
lexeme_data <- db |> 
  filter(feature_id == 56) |>  # First filter by feature_id
  filter(feature_lexeme == "‘<III>sleep=PRS’ /sawχur a/") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0) {
  # Prepare data for display
  display_data <- lexeme_data |>
    select(settlement, value, stimuli, answer, collected) |>
    arrange(settlement, value)
  
  # Use DT package for interactive table
  DT::datatable(display_data, 
                class = "cell-border stripe",
                rownames = FALSE,
                filter = "top",
                options = list(pageLength = 25, 
                             autoWidth = TRUE,
                             info = FALSE))
} else {
  cat("Данные для этой лексемы недоступны.\n")
}
```

:::

## ‘ceiling, roof’ /ɢaw/

::: {.panel-tabset}

### Карта

```{r}
# Load data for this lexeme
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(lingtypology)

# Read the database and villages data
db <- read_csv("../data/database.csv", show_col_types = FALSE)
villages <- read_csv("../data/villages.csv", show_col_types = FALSE)

# Filter villages like in original script (exclude certain villages)
villages4map <- villages |>
  filter(!(village %in% c("Kazankulak", "Novyy Borch", "Vrush", "Aran", "Khnyukh")))

# Create mapping data for this lexeme
lexeme_data <- db |>
  filter(feature_id == 56) |>  # First filter by feature_id
  filter(feature_lexeme == "‘ceiling, roof’ /ɢaw/") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {
  # Create mapping data for this lexeme
  mapping_data <- lexeme_data |>
    mutate(value = str_split(value, " ; ")) |>
    unnest_longer(value) |>
    distinct(settlement, value) |>
    mutate(n = 1) |>
    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>
    left_join(villages4map[,c("village","lat","lon")], by = c("settlement" = "village")) |>
    mutate(language = "Rutul") |>
    filter(!is.na(lat) & !is.na(lon))

  if (nrow(mapping_data) > 0) {
    # Convert feature columns to numeric
    feature_cols <- setdiff(colnames(mapping_data), c("settlement","lat","lon","language"))
    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))

    # Create sophisticated mapping approach with ALWAYS visible village names
    if(length(feature_cols) == 1){
      # single feature column - show all villages in gray, feature data in color
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)

      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE,
                                width = 10,
                                tile = "OpenStreetMap.HOT",
                                features = feature_cols)

      # Show both maps
      base_map
      feature_map
    } else {
      # multiple feature columns - use pie charts with ALWAYS visible village names
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)

      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                minichart.data = mapping_data |> select(all_of(feature_cols)),
                                minichart = "pie",
                                width = 3,
                                tile = "OpenStreetMap.HOT",
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE)

      # Show both maps
      base_map
      feature_map
    }
  } else {
    cat("Географические координаты недоступны для картографирования.\n")
  }
} else {
  cat("Данные для этой лексемы недоступны или координаты деревень не найдены.\n")
}
```

### Данные

```{r}
# Load required libraries
library(readr)
library(dplyr)
library(DT)

# Read the database data
db <- read_csv("../data/database.csv", show_col_types = FALSE)

# Create interactive table for this lexeme
lexeme_data <- db |> 
  filter(feature_id == 56) |>  # First filter by feature_id
  filter(feature_lexeme == "‘ceiling, roof’ /ɢaw/") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0) {
  # Prepare data for display
  display_data <- lexeme_data |>
    select(settlement, value, stimuli, answer, collected) |>
    arrange(settlement, value)
  
  # Use DT package for interactive table
  DT::datatable(display_data, 
                class = "cell-border stripe",
                rownames = FALSE,
                filter = "top",
                options = list(pageLength = 25, 
                             autoWidth = TRUE,
                             info = FALSE))
} else {
  cat("Данные для этой лексемы недоступны.\n")
}
```

:::

## ‘poison’ /awʁu/

::: {.panel-tabset}

### Карта

```{r}
# Load data for this lexeme
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(lingtypology)

# Read the database and villages data
db <- read_csv("../data/database.csv", show_col_types = FALSE)
villages <- read_csv("../data/villages.csv", show_col_types = FALSE)

# Filter villages like in original script (exclude certain villages)
villages4map <- villages |>
  filter(!(village %in% c("Kazankulak", "Novyy Borch", "Vrush", "Aran", "Khnyukh")))

# Create mapping data for this lexeme
lexeme_data <- db |>
  filter(feature_id == 56) |>  # First filter by feature_id
  filter(feature_lexeme == "‘poison’ /awʁu/") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {
  # Create mapping data for this lexeme
  mapping_data <- lexeme_data |>
    mutate(value = str_split(value, " ; ")) |>
    unnest_longer(value) |>
    distinct(settlement, value) |>
    mutate(n = 1) |>
    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>
    left_join(villages4map[,c("village","lat","lon")], by = c("settlement" = "village")) |>
    mutate(language = "Rutul") |>
    filter(!is.na(lat) & !is.na(lon))

  if (nrow(mapping_data) > 0) {
    # Convert feature columns to numeric
    feature_cols <- setdiff(colnames(mapping_data), c("settlement","lat","lon","language"))
    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))

    # Create sophisticated mapping approach with ALWAYS visible village names
    if(length(feature_cols) == 1){
      # single feature column - show all villages in gray, feature data in color
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)

      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE,
                                width = 10,
                                tile = "OpenStreetMap.HOT",
                                features = feature_cols)

      # Show both maps
      base_map
      feature_map
    } else {
      # multiple feature columns - use pie charts with ALWAYS visible village names
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)

      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                minichart.data = mapping_data |> select(all_of(feature_cols)),
                                minichart = "pie",
                                width = 3,
                                tile = "OpenStreetMap.HOT",
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE)

      # Show both maps
      base_map
      feature_map
    }
  } else {
    cat("Географические координаты недоступны для картографирования.\n")
  }
} else {
  cat("Данные для этой лексемы недоступны или координаты деревень не найдены.\n")
}
```

### Данные

```{r}
# Load required libraries
library(readr)
library(dplyr)
library(DT)

# Read the database data
db <- read_csv("../data/database.csv", show_col_types = FALSE)

# Create interactive table for this lexeme
lexeme_data <- db |> 
  filter(feature_id == 56) |>  # First filter by feature_id
  filter(feature_lexeme == "‘poison’ /awʁu/") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0) {
  # Prepare data for display
  display_data <- lexeme_data |>
    select(settlement, value, stimuli, answer, collected) |>
    arrange(settlement, value)
  
  # Use DT package for interactive table
  DT::datatable(display_data, 
                class = "cell-border stripe",
                rownames = FALSE,
                filter = "top",
                options = list(pageLength = 25, 
                             autoWidth = TRUE,
                             info = FALSE))
} else {
  cat("Данные для этой лексемы недоступны.\n")
}
```

:::

