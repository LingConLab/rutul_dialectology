---
title: "The verb ‘become’: imperative and prohibitive"
author: "Timur Maisak"
date: 2025-08-28
format: html
lang: ru
css: styles.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 9.5)
```

The verb 'become' is one of the most frequent verbs in Rutul. It has several suppletive stems, with cross-dialectal variation in their phonological form. For the imperative, the stimulus sentence was 'Become a doctor!' (addressed to a boy). For the prohibitive (negative imperative), the stimulus sentence was 'Don't become a doctor!' (addressed to a boy). The prohibitive prefix is *ma-* / *me-*.
As the map value, the full form of the imperative or prohibitive is given. The gender is unmarked in both forms (in the "weak" gender agreement series, masculine has zero affix).


## Imperative

::: {.panel-tabset}

### Карта

```{r}
# Load data for this lexeme
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(lingtypology)

# Read the database and villages data
db <- read_csv("../data/database.csv", show_col_types = FALSE)
villages <- read_csv("../data/villages.csv", show_col_types = FALSE)

# Filter villages like in original script (exclude certain villages)
villages4map <- villages |>
  filter(!(village %in% c("Kazankulak", "Novyy Borch", "Vrush", "Aran", "Khnyukh")))

# Create mapping data for this lexeme
lexeme_data <- db |>
  filter(feature_id == 169) |>  # First filter by feature_id
  filter(feature_lexeme == "Imperative") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {
  # Create mapping data for this lexeme
  mapping_data <- lexeme_data |>
    mutate(value = str_split(value, " ; ")) |>
    unnest_longer(value) |>
    distinct(settlement, value) |>
    mutate(n = 1) |>
    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>
    left_join(villages4map[,c("village","lat","lon")], by = c("settlement" = "village")) |>
    mutate(language = "Rutul") |>
    filter(!is.na(lat) & !is.na(lon))

  if (nrow(mapping_data) > 0) {
    # Convert feature columns to numeric
    feature_cols <- setdiff(colnames(mapping_data), c("settlement","lat","lon","language"))
    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))

    # Create sophisticated mapping approach with ALWAYS visible village names
    if(length(feature_cols) == 1){
      # single feature column - show all villages in gray, feature data in color
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)

      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE,
                                width = 10,
                                tile = "OpenStreetMap.HOT",
                                features = feature_cols)

      # Show both maps
      base_map
      feature_map
    } else {
      # multiple feature columns - use pie charts with ALWAYS visible village names
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)

      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                minichart.data = mapping_data |> select(all_of(feature_cols)),
                                minichart = "pie",
                                width = 3,
                                tile = "OpenStreetMap.HOT",
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE)

      # Show both maps
      base_map
      feature_map
    }
  } else {
    cat("Географические координаты недоступны для картографирования.\n")
  }
} else {
  cat("Данные для этой лексемы недоступны или координаты деревень не найдены.\n")
}
```

### Данные

```{r}
# Load required libraries
library(readr)
library(dplyr)
library(DT)

# Read the database data
db <- read_csv("../data/database.csv", show_col_types = FALSE)

# Create interactive table for this lexeme
lexeme_data <- db |> 
  filter(feature_id == 169) |>  # First filter by feature_id
  filter(feature_lexeme == "Imperative") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0) {
  # Prepare data for display
  display_data <- lexeme_data |>
    select(settlement, value, stimuli, answer, collected) |>
    arrange(settlement, value)
  
  # Use DT package for interactive table
  DT::datatable(display_data, 
                class = "cell-border stripe",
                rownames = FALSE,
                filter = "top",
                options = list(pageLength = 25, 
                             autoWidth = TRUE,
                             info = FALSE))
} else {
  cat("Данные для этой лексемы недоступны.\n")
}
```

:::

## Prohibitive

::: {.panel-tabset}

### Карта

```{r}
# Load data for this lexeme
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(lingtypology)

# Read the database and villages data
db <- read_csv("../data/database.csv", show_col_types = FALSE)
villages <- read_csv("../data/villages.csv", show_col_types = FALSE)

# Filter villages like in original script (exclude certain villages)
villages4map <- villages |>
  filter(!(village %in% c("Kazankulak", "Novyy Borch", "Vrush", "Aran", "Khnyukh")))

# Create mapping data for this lexeme
lexeme_data <- db |>
  filter(feature_id == 169) |>  # First filter by feature_id
  filter(feature_lexeme == "Prohibitive") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {
  # Create mapping data for this lexeme
  mapping_data <- lexeme_data |>
    mutate(value = str_split(value, " ; ")) |>
    unnest_longer(value) |>
    distinct(settlement, value) |>
    mutate(n = 1) |>
    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>
    left_join(villages4map[,c("village","lat","lon")], by = c("settlement" = "village")) |>
    mutate(language = "Rutul") |>
    filter(!is.na(lat) & !is.na(lon))

  if (nrow(mapping_data) > 0) {
    # Convert feature columns to numeric
    feature_cols <- setdiff(colnames(mapping_data), c("settlement","lat","lon","language"))
    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))

    # Create sophisticated mapping approach with ALWAYS visible village names
    if(length(feature_cols) == 1){
      # single feature column - show all villages in gray, feature data in color
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)

      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE,
                                width = 10,
                                tile = "OpenStreetMap.HOT",
                                features = feature_cols)

      # Show both maps
      base_map
      feature_map
    } else {
      # multiple feature columns - use pie charts with ALWAYS visible village names
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)

      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                minichart.data = mapping_data |> select(all_of(feature_cols)),
                                minichart = "pie",
                                width = 3,
                                tile = "OpenStreetMap.HOT",
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE)

      # Show both maps
      base_map
      feature_map
    }
  } else {
    cat("Географические координаты недоступны для картографирования.\n")
  }
} else {
  cat("Данные для этой лексемы недоступны или координаты деревень не найдены.\n")
}
```

### Данные

```{r}
# Load required libraries
library(readr)
library(dplyr)
library(DT)

# Read the database data
db <- read_csv("../data/database.csv", show_col_types = FALSE)

# Create interactive table for this lexeme
lexeme_data <- db |> 
  filter(feature_id == 169) |>  # First filter by feature_id
  filter(feature_lexeme == "Prohibitive") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0) {
  # Prepare data for display
  display_data <- lexeme_data |>
    select(settlement, value, stimuli, answer, collected) |>
    arrange(settlement, value)
  
  # Use DT package for interactive table
  DT::datatable(display_data, 
                class = "cell-border stripe",
                rownames = FALSE,
                filter = "top",
                options = list(pageLength = 25, 
                             autoWidth = TRUE,
                             info = FALSE))
} else {
  cat("Данные для этой лексемы недоступны.\n")
}
```

:::

