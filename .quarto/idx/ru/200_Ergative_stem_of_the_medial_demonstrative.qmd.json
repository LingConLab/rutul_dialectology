{"title":"Ergative stem of the medial demonstrative","markdown":{"yaml":{"title":"Ergative stem of the medial demonstrative","author":"Maksim Melenchenko","date":"2025-08-28","format":"html","lang":"ru","css":"styles.css"},"headingText":"singular, human","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 9.5)\n```\n\nThis feature shows the specific form of the ergative stem of the medial (*ha*-) demonstrative. This is the stem used in the ergative form of the demonstrative, followed by the ergative suffix. There are four contexts to distinguish between human / non-human referents and singular / plural referents. The speakers were asked to translate four sentences: ‘**He** said that’ (human singular), ‘**They** said that’ (human plural), ‘[The cow died.] **She** ate bad grass’ (non-human singular), ‘[The cows died.] **They** ate bad grass’ (non-human plural). For each speaker, first reaction was coded (although the elicitor tried to make sure that this reaction was not an error due to the misunderstanding of the context).\nErgative stem for singular human referents is *ha-nu-* / *ha-now-* in Ikhrek, Myukhrek, Kina, Luchek and adjacent villages; *ha-na-* in Shinaz; *ha-ni(j)* in Rutul and adjacent villages. With singular non-human referents, greater variance is observed: *ha-ni-* in Ikhrek; *ha-ji-* in Kina and Luchek; *ha-dɨ-* in Rutul and adjacent villages; *ha-jdi-* / *ha-jdɨ-* in Myukhrek, Shinaz and adjacent villages. In Khnov, the distinction between the singular and the plural form was neutralized in the form *ha-na-*, which is used in both contexts.\nErgative stem for plural human referents is *ha-biš-* / *ha-bɨš-* in all villages except Khnov. With plural referents, stem *ha-jmɨ-* is attested in Myukhrek, Shinaz, Luchek and adjacent villages, while in Ikhrek and the villages close to Rutul, *ha-(m)mɨ-* is used. In Khnov, the singular and the plural were neutralized in the plural form *ha-(m)mɨ-*, which is used in both contexts.\n\n\n\n::: {.panel-tabset}\n\n### Карта\n\n```{r}\n# Load data for this lexeme\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(lingtypology)\n\n# Read the database and villages data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\nvillages <- read_csv(\"../data/villages.csv\", show_col_types = FALSE)\n\n# Filter villages like in original script (exclude certain villages)\nvillages4map <- villages |>\n  filter(!(village %in% c(\"Kazankulak\", \"Novyy Borch\", \"Vrush\", \"Aran\", \"Khnyukh\")))\n\n# Create mapping data for this lexeme\nlexeme_data <- db |>\n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"singular, human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {\n  # Create mapping data for this lexeme\n  mapping_data <- lexeme_data |>\n    mutate(value = str_split(value, \" ; \")) |>\n    unnest_longer(value) |>\n    distinct(settlement, value) |>\n    mutate(n = 1) |>\n    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>\n    left_join(villages4map[,c(\"village\",\"lat\",\"lon\")], by = c(\"settlement\" = \"village\")) |>\n    mutate(language = \"Rutul\") |>\n    filter(!is.na(lat) & !is.na(lon))\n\n  if (nrow(mapping_data) > 0) {\n    # Convert feature columns to numeric\n    feature_cols <- setdiff(colnames(mapping_data), c(\"settlement\",\"lat\",\"lon\",\"language\"))\n    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))\n\n    # Create sophisticated mapping approach with ALWAYS visible village names\n    if(length(feature_cols) == 1){\n      # single feature column - show all villages in gray, feature data in color\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE,\n                                width = 10,\n                                tile = \"OpenStreetMap.HOT\",\n                                features = feature_cols)\n\n      # Show both maps\n      base_map\n      feature_map\n    } else {\n      # multiple feature columns - use pie charts with ALWAYS visible village names\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                minichart.data = mapping_data |> select(all_of(feature_cols)),\n                                minichart = \"pie\",\n                                width = 3,\n                                tile = \"OpenStreetMap.HOT\",\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE)\n\n      # Show both maps\n      base_map\n      feature_map\n    }\n  } else {\n    cat(\"Географические координаты недоступны для картографирования.\\n\")\n  }\n} else {\n  cat(\"Данные для этой лексемы недоступны или координаты деревень не найдены.\\n\")\n}\n```\n\n### Данные\n\n```{r}\n# Load required libraries\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\n\n# Read the database data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\n\n# Create interactive table for this lexeme\nlexeme_data <- db |> \n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"singular, human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0) {\n  # Prepare data for display\n  display_data <- lexeme_data |>\n    select(settlement, value, stimuli, answer, collected) |>\n    arrange(settlement, value)\n  \n  # Use DT package for interactive table\n  DT::datatable(display_data, \n                class = \"cell-border stripe\",\n                rownames = FALSE,\n                filter = \"top\",\n                options = list(pageLength = 25, \n                             autoWidth = TRUE,\n                             info = FALSE))\n} else {\n  cat(\"Данные для этой лексемы недоступны.\\n\")\n}\n```\n\n:::\n\n## singular, non-human\n\n::: {.panel-tabset}\n\n### Карта\n\n```{r}\n# Load data for this lexeme\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(lingtypology)\n\n# Read the database and villages data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\nvillages <- read_csv(\"../data/villages.csv\", show_col_types = FALSE)\n\n# Filter villages like in original script (exclude certain villages)\nvillages4map <- villages |>\n  filter(!(village %in% c(\"Kazankulak\", \"Novyy Borch\", \"Vrush\", \"Aran\", \"Khnyukh\")))\n\n# Create mapping data for this lexeme\nlexeme_data <- db |>\n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"singular, non-human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {\n  # Create mapping data for this lexeme\n  mapping_data <- lexeme_data |>\n    mutate(value = str_split(value, \" ; \")) |>\n    unnest_longer(value) |>\n    distinct(settlement, value) |>\n    mutate(n = 1) |>\n    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>\n    left_join(villages4map[,c(\"village\",\"lat\",\"lon\")], by = c(\"settlement\" = \"village\")) |>\n    mutate(language = \"Rutul\") |>\n    filter(!is.na(lat) & !is.na(lon))\n\n  if (nrow(mapping_data) > 0) {\n    # Convert feature columns to numeric\n    feature_cols <- setdiff(colnames(mapping_data), c(\"settlement\",\"lat\",\"lon\",\"language\"))\n    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))\n\n    # Create sophisticated mapping approach with ALWAYS visible village names\n    if(length(feature_cols) == 1){\n      # single feature column - show all villages in gray, feature data in color\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE,\n                                width = 10,\n                                tile = \"OpenStreetMap.HOT\",\n                                features = feature_cols)\n\n      # Show both maps\n      base_map\n      feature_map\n    } else {\n      # multiple feature columns - use pie charts with ALWAYS visible village names\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                minichart.data = mapping_data |> select(all_of(feature_cols)),\n                                minichart = \"pie\",\n                                width = 3,\n                                tile = \"OpenStreetMap.HOT\",\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE)\n\n      # Show both maps\n      base_map\n      feature_map\n    }\n  } else {\n    cat(\"Географические координаты недоступны для картографирования.\\n\")\n  }\n} else {\n  cat(\"Данные для этой лексемы недоступны или координаты деревень не найдены.\\n\")\n}\n```\n\n### Данные\n\n```{r}\n# Load required libraries\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\n\n# Read the database data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\n\n# Create interactive table for this lexeme\nlexeme_data <- db |> \n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"singular, non-human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0) {\n  # Prepare data for display\n  display_data <- lexeme_data |>\n    select(settlement, value, stimuli, answer, collected) |>\n    arrange(settlement, value)\n  \n  # Use DT package for interactive table\n  DT::datatable(display_data, \n                class = \"cell-border stripe\",\n                rownames = FALSE,\n                filter = \"top\",\n                options = list(pageLength = 25, \n                             autoWidth = TRUE,\n                             info = FALSE))\n} else {\n  cat(\"Данные для этой лексемы недоступны.\\n\")\n}\n```\n\n:::\n\n## plural, human\n\n::: {.panel-tabset}\n\n### Карта\n\n```{r}\n# Load data for this lexeme\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(lingtypology)\n\n# Read the database and villages data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\nvillages <- read_csv(\"../data/villages.csv\", show_col_types = FALSE)\n\n# Filter villages like in original script (exclude certain villages)\nvillages4map <- villages |>\n  filter(!(village %in% c(\"Kazankulak\", \"Novyy Borch\", \"Vrush\", \"Aran\", \"Khnyukh\")))\n\n# Create mapping data for this lexeme\nlexeme_data <- db |>\n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"plural, human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {\n  # Create mapping data for this lexeme\n  mapping_data <- lexeme_data |>\n    mutate(value = str_split(value, \" ; \")) |>\n    unnest_longer(value) |>\n    distinct(settlement, value) |>\n    mutate(n = 1) |>\n    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>\n    left_join(villages4map[,c(\"village\",\"lat\",\"lon\")], by = c(\"settlement\" = \"village\")) |>\n    mutate(language = \"Rutul\") |>\n    filter(!is.na(lat) & !is.na(lon))\n\n  if (nrow(mapping_data) > 0) {\n    # Convert feature columns to numeric\n    feature_cols <- setdiff(colnames(mapping_data), c(\"settlement\",\"lat\",\"lon\",\"language\"))\n    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))\n\n    # Create sophisticated mapping approach with ALWAYS visible village names\n    if(length(feature_cols) == 1){\n      # single feature column - show all villages in gray, feature data in color\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE,\n                                width = 10,\n                                tile = \"OpenStreetMap.HOT\",\n                                features = feature_cols)\n\n      # Show both maps\n      base_map\n      feature_map\n    } else {\n      # multiple feature columns - use pie charts with ALWAYS visible village names\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                minichart.data = mapping_data |> select(all_of(feature_cols)),\n                                minichart = \"pie\",\n                                width = 3,\n                                tile = \"OpenStreetMap.HOT\",\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE)\n\n      # Show both maps\n      base_map\n      feature_map\n    }\n  } else {\n    cat(\"Географические координаты недоступны для картографирования.\\n\")\n  }\n} else {\n  cat(\"Данные для этой лексемы недоступны или координаты деревень не найдены.\\n\")\n}\n```\n\n### Данные\n\n```{r}\n# Load required libraries\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\n\n# Read the database data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\n\n# Create interactive table for this lexeme\nlexeme_data <- db |> \n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"plural, human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0) {\n  # Prepare data for display\n  display_data <- lexeme_data |>\n    select(settlement, value, stimuli, answer, collected) |>\n    arrange(settlement, value)\n  \n  # Use DT package for interactive table\n  DT::datatable(display_data, \n                class = \"cell-border stripe\",\n                rownames = FALSE,\n                filter = \"top\",\n                options = list(pageLength = 25, \n                             autoWidth = TRUE,\n                             info = FALSE))\n} else {\n  cat(\"Данные для этой лексемы недоступны.\\n\")\n}\n```\n\n:::\n\n## plural, non-human\n\n::: {.panel-tabset}\n\n### Карта\n\n```{r}\n# Load data for this lexeme\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(lingtypology)\n\n# Read the database and villages data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\nvillages <- read_csv(\"../data/villages.csv\", show_col_types = FALSE)\n\n# Filter villages like in original script (exclude certain villages)\nvillages4map <- villages |>\n  filter(!(village %in% c(\"Kazankulak\", \"Novyy Borch\", \"Vrush\", \"Aran\", \"Khnyukh\")))\n\n# Create mapping data for this lexeme\nlexeme_data <- db |>\n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"plural, non-human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {\n  # Create mapping data for this lexeme\n  mapping_data <- lexeme_data |>\n    mutate(value = str_split(value, \" ; \")) |>\n    unnest_longer(value) |>\n    distinct(settlement, value) |>\n    mutate(n = 1) |>\n    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>\n    left_join(villages4map[,c(\"village\",\"lat\",\"lon\")], by = c(\"settlement\" = \"village\")) |>\n    mutate(language = \"Rutul\") |>\n    filter(!is.na(lat) & !is.na(lon))\n\n  if (nrow(mapping_data) > 0) {\n    # Convert feature columns to numeric\n    feature_cols <- setdiff(colnames(mapping_data), c(\"settlement\",\"lat\",\"lon\",\"language\"))\n    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))\n\n    # Create sophisticated mapping approach with ALWAYS visible village names\n    if(length(feature_cols) == 1){\n      # single feature column - show all villages in gray, feature data in color\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE,\n                                width = 10,\n                                tile = \"OpenStreetMap.HOT\",\n                                features = feature_cols)\n\n      # Show both maps\n      base_map\n      feature_map\n    } else {\n      # multiple feature columns - use pie charts with ALWAYS visible village names\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                minichart.data = mapping_data |> select(all_of(feature_cols)),\n                                minichart = \"pie\",\n                                width = 3,\n                                tile = \"OpenStreetMap.HOT\",\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE)\n\n      # Show both maps\n      base_map\n      feature_map\n    }\n  } else {\n    cat(\"Географические координаты недоступны для картографирования.\\n\")\n  }\n} else {\n  cat(\"Данные для этой лексемы недоступны или координаты деревень не найдены.\\n\")\n}\n```\n\n### Данные\n\n```{r}\n# Load required libraries\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\n\n# Read the database data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\n\n# Create interactive table for this lexeme\nlexeme_data <- db |> \n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"plural, non-human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0) {\n  # Prepare data for display\n  display_data <- lexeme_data |>\n    select(settlement, value, stimuli, answer, collected) |>\n    arrange(settlement, value)\n  \n  # Use DT package for interactive table\n  DT::datatable(display_data, \n                class = \"cell-border stripe\",\n                rownames = FALSE,\n                filter = \"top\",\n                options = list(pageLength = 25, \n                             autoWidth = TRUE,\n                             info = FALSE))\n} else {\n  cat(\"Данные для этой лексемы недоступны.\\n\")\n}\n```\n\n:::\n\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 9.5)\n```\n\nThis feature shows the specific form of the ergative stem of the medial (*ha*-) demonstrative. This is the stem used in the ergative form of the demonstrative, followed by the ergative suffix. There are four contexts to distinguish between human / non-human referents and singular / plural referents. The speakers were asked to translate four sentences: ‘**He** said that’ (human singular), ‘**They** said that’ (human plural), ‘[The cow died.] **She** ate bad grass’ (non-human singular), ‘[The cows died.] **They** ate bad grass’ (non-human plural). For each speaker, first reaction was coded (although the elicitor tried to make sure that this reaction was not an error due to the misunderstanding of the context).\nErgative stem for singular human referents is *ha-nu-* / *ha-now-* in Ikhrek, Myukhrek, Kina, Luchek and adjacent villages; *ha-na-* in Shinaz; *ha-ni(j)* in Rutul and adjacent villages. With singular non-human referents, greater variance is observed: *ha-ni-* in Ikhrek; *ha-ji-* in Kina and Luchek; *ha-dɨ-* in Rutul and adjacent villages; *ha-jdi-* / *ha-jdɨ-* in Myukhrek, Shinaz and adjacent villages. In Khnov, the distinction between the singular and the plural form was neutralized in the form *ha-na-*, which is used in both contexts.\nErgative stem for plural human referents is *ha-biš-* / *ha-bɨš-* in all villages except Khnov. With plural referents, stem *ha-jmɨ-* is attested in Myukhrek, Shinaz, Luchek and adjacent villages, while in Ikhrek and the villages close to Rutul, *ha-(m)mɨ-* is used. In Khnov, the singular and the plural were neutralized in the plural form *ha-(m)mɨ-*, which is used in both contexts.\n\n\n## singular, human\n\n::: {.panel-tabset}\n\n### Карта\n\n```{r}\n# Load data for this lexeme\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(lingtypology)\n\n# Read the database and villages data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\nvillages <- read_csv(\"../data/villages.csv\", show_col_types = FALSE)\n\n# Filter villages like in original script (exclude certain villages)\nvillages4map <- villages |>\n  filter(!(village %in% c(\"Kazankulak\", \"Novyy Borch\", \"Vrush\", \"Aran\", \"Khnyukh\")))\n\n# Create mapping data for this lexeme\nlexeme_data <- db |>\n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"singular, human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {\n  # Create mapping data for this lexeme\n  mapping_data <- lexeme_data |>\n    mutate(value = str_split(value, \" ; \")) |>\n    unnest_longer(value) |>\n    distinct(settlement, value) |>\n    mutate(n = 1) |>\n    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>\n    left_join(villages4map[,c(\"village\",\"lat\",\"lon\")], by = c(\"settlement\" = \"village\")) |>\n    mutate(language = \"Rutul\") |>\n    filter(!is.na(lat) & !is.na(lon))\n\n  if (nrow(mapping_data) > 0) {\n    # Convert feature columns to numeric\n    feature_cols <- setdiff(colnames(mapping_data), c(\"settlement\",\"lat\",\"lon\",\"language\"))\n    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))\n\n    # Create sophisticated mapping approach with ALWAYS visible village names\n    if(length(feature_cols) == 1){\n      # single feature column - show all villages in gray, feature data in color\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE,\n                                width = 10,\n                                tile = \"OpenStreetMap.HOT\",\n                                features = feature_cols)\n\n      # Show both maps\n      base_map\n      feature_map\n    } else {\n      # multiple feature columns - use pie charts with ALWAYS visible village names\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                minichart.data = mapping_data |> select(all_of(feature_cols)),\n                                minichart = \"pie\",\n                                width = 3,\n                                tile = \"OpenStreetMap.HOT\",\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE)\n\n      # Show both maps\n      base_map\n      feature_map\n    }\n  } else {\n    cat(\"Географические координаты недоступны для картографирования.\\n\")\n  }\n} else {\n  cat(\"Данные для этой лексемы недоступны или координаты деревень не найдены.\\n\")\n}\n```\n\n### Данные\n\n```{r}\n# Load required libraries\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\n\n# Read the database data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\n\n# Create interactive table for this lexeme\nlexeme_data <- db |> \n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"singular, human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0) {\n  # Prepare data for display\n  display_data <- lexeme_data |>\n    select(settlement, value, stimuli, answer, collected) |>\n    arrange(settlement, value)\n  \n  # Use DT package for interactive table\n  DT::datatable(display_data, \n                class = \"cell-border stripe\",\n                rownames = FALSE,\n                filter = \"top\",\n                options = list(pageLength = 25, \n                             autoWidth = TRUE,\n                             info = FALSE))\n} else {\n  cat(\"Данные для этой лексемы недоступны.\\n\")\n}\n```\n\n:::\n\n## singular, non-human\n\n::: {.panel-tabset}\n\n### Карта\n\n```{r}\n# Load data for this lexeme\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(lingtypology)\n\n# Read the database and villages data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\nvillages <- read_csv(\"../data/villages.csv\", show_col_types = FALSE)\n\n# Filter villages like in original script (exclude certain villages)\nvillages4map <- villages |>\n  filter(!(village %in% c(\"Kazankulak\", \"Novyy Borch\", \"Vrush\", \"Aran\", \"Khnyukh\")))\n\n# Create mapping data for this lexeme\nlexeme_data <- db |>\n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"singular, non-human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {\n  # Create mapping data for this lexeme\n  mapping_data <- lexeme_data |>\n    mutate(value = str_split(value, \" ; \")) |>\n    unnest_longer(value) |>\n    distinct(settlement, value) |>\n    mutate(n = 1) |>\n    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>\n    left_join(villages4map[,c(\"village\",\"lat\",\"lon\")], by = c(\"settlement\" = \"village\")) |>\n    mutate(language = \"Rutul\") |>\n    filter(!is.na(lat) & !is.na(lon))\n\n  if (nrow(mapping_data) > 0) {\n    # Convert feature columns to numeric\n    feature_cols <- setdiff(colnames(mapping_data), c(\"settlement\",\"lat\",\"lon\",\"language\"))\n    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))\n\n    # Create sophisticated mapping approach with ALWAYS visible village names\n    if(length(feature_cols) == 1){\n      # single feature column - show all villages in gray, feature data in color\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE,\n                                width = 10,\n                                tile = \"OpenStreetMap.HOT\",\n                                features = feature_cols)\n\n      # Show both maps\n      base_map\n      feature_map\n    } else {\n      # multiple feature columns - use pie charts with ALWAYS visible village names\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                minichart.data = mapping_data |> select(all_of(feature_cols)),\n                                minichart = \"pie\",\n                                width = 3,\n                                tile = \"OpenStreetMap.HOT\",\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE)\n\n      # Show both maps\n      base_map\n      feature_map\n    }\n  } else {\n    cat(\"Географические координаты недоступны для картографирования.\\n\")\n  }\n} else {\n  cat(\"Данные для этой лексемы недоступны или координаты деревень не найдены.\\n\")\n}\n```\n\n### Данные\n\n```{r}\n# Load required libraries\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\n\n# Read the database data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\n\n# Create interactive table for this lexeme\nlexeme_data <- db |> \n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"singular, non-human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0) {\n  # Prepare data for display\n  display_data <- lexeme_data |>\n    select(settlement, value, stimuli, answer, collected) |>\n    arrange(settlement, value)\n  \n  # Use DT package for interactive table\n  DT::datatable(display_data, \n                class = \"cell-border stripe\",\n                rownames = FALSE,\n                filter = \"top\",\n                options = list(pageLength = 25, \n                             autoWidth = TRUE,\n                             info = FALSE))\n} else {\n  cat(\"Данные для этой лексемы недоступны.\\n\")\n}\n```\n\n:::\n\n## plural, human\n\n::: {.panel-tabset}\n\n### Карта\n\n```{r}\n# Load data for this lexeme\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(lingtypology)\n\n# Read the database and villages data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\nvillages <- read_csv(\"../data/villages.csv\", show_col_types = FALSE)\n\n# Filter villages like in original script (exclude certain villages)\nvillages4map <- villages |>\n  filter(!(village %in% c(\"Kazankulak\", \"Novyy Borch\", \"Vrush\", \"Aran\", \"Khnyukh\")))\n\n# Create mapping data for this lexeme\nlexeme_data <- db |>\n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"plural, human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {\n  # Create mapping data for this lexeme\n  mapping_data <- lexeme_data |>\n    mutate(value = str_split(value, \" ; \")) |>\n    unnest_longer(value) |>\n    distinct(settlement, value) |>\n    mutate(n = 1) |>\n    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>\n    left_join(villages4map[,c(\"village\",\"lat\",\"lon\")], by = c(\"settlement\" = \"village\")) |>\n    mutate(language = \"Rutul\") |>\n    filter(!is.na(lat) & !is.na(lon))\n\n  if (nrow(mapping_data) > 0) {\n    # Convert feature columns to numeric\n    feature_cols <- setdiff(colnames(mapping_data), c(\"settlement\",\"lat\",\"lon\",\"language\"))\n    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))\n\n    # Create sophisticated mapping approach with ALWAYS visible village names\n    if(length(feature_cols) == 1){\n      # single feature column - show all villages in gray, feature data in color\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE,\n                                width = 10,\n                                tile = \"OpenStreetMap.HOT\",\n                                features = feature_cols)\n\n      # Show both maps\n      base_map\n      feature_map\n    } else {\n      # multiple feature columns - use pie charts with ALWAYS visible village names\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                minichart.data = mapping_data |> select(all_of(feature_cols)),\n                                minichart = \"pie\",\n                                width = 3,\n                                tile = \"OpenStreetMap.HOT\",\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE)\n\n      # Show both maps\n      base_map\n      feature_map\n    }\n  } else {\n    cat(\"Географические координаты недоступны для картографирования.\\n\")\n  }\n} else {\n  cat(\"Данные для этой лексемы недоступны или координаты деревень не найдены.\\n\")\n}\n```\n\n### Данные\n\n```{r}\n# Load required libraries\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\n\n# Read the database data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\n\n# Create interactive table for this lexeme\nlexeme_data <- db |> \n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"plural, human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0) {\n  # Prepare data for display\n  display_data <- lexeme_data |>\n    select(settlement, value, stimuli, answer, collected) |>\n    arrange(settlement, value)\n  \n  # Use DT package for interactive table\n  DT::datatable(display_data, \n                class = \"cell-border stripe\",\n                rownames = FALSE,\n                filter = \"top\",\n                options = list(pageLength = 25, \n                             autoWidth = TRUE,\n                             info = FALSE))\n} else {\n  cat(\"Данные для этой лексемы недоступны.\\n\")\n}\n```\n\n:::\n\n## plural, non-human\n\n::: {.panel-tabset}\n\n### Карта\n\n```{r}\n# Load data for this lexeme\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(lingtypology)\n\n# Read the database and villages data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\nvillages <- read_csv(\"../data/villages.csv\", show_col_types = FALSE)\n\n# Filter villages like in original script (exclude certain villages)\nvillages4map <- villages |>\n  filter(!(village %in% c(\"Kazankulak\", \"Novyy Borch\", \"Vrush\", \"Aran\", \"Khnyukh\")))\n\n# Create mapping data for this lexeme\nlexeme_data <- db |>\n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"plural, non-human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {\n  # Create mapping data for this lexeme\n  mapping_data <- lexeme_data |>\n    mutate(value = str_split(value, \" ; \")) |>\n    unnest_longer(value) |>\n    distinct(settlement, value) |>\n    mutate(n = 1) |>\n    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>\n    left_join(villages4map[,c(\"village\",\"lat\",\"lon\")], by = c(\"settlement\" = \"village\")) |>\n    mutate(language = \"Rutul\") |>\n    filter(!is.na(lat) & !is.na(lon))\n\n  if (nrow(mapping_data) > 0) {\n    # Convert feature columns to numeric\n    feature_cols <- setdiff(colnames(mapping_data), c(\"settlement\",\"lat\",\"lon\",\"language\"))\n    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))\n\n    # Create sophisticated mapping approach with ALWAYS visible village names\n    if(length(feature_cols) == 1){\n      # single feature column - show all villages in gray, feature data in color\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE,\n                                width = 10,\n                                tile = \"OpenStreetMap.HOT\",\n                                features = feature_cols)\n\n      # Show both maps\n      base_map\n      feature_map\n    } else {\n      # multiple feature columns - use pie charts with ALWAYS visible village names\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                minichart.data = mapping_data |> select(all_of(feature_cols)),\n                                minichart = \"pie\",\n                                width = 3,\n                                tile = \"OpenStreetMap.HOT\",\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE)\n\n      # Show both maps\n      base_map\n      feature_map\n    }\n  } else {\n    cat(\"Географические координаты недоступны для картографирования.\\n\")\n  }\n} else {\n  cat(\"Данные для этой лексемы недоступны или координаты деревень не найдены.\\n\")\n}\n```\n\n### Данные\n\n```{r}\n# Load required libraries\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\n\n# Read the database data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\n\n# Create interactive table for this lexeme\nlexeme_data <- db |> \n  filter(feature_id == 200) |>  # First filter by feature_id\n  filter(feature_lexeme == \"plural, non-human\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0) {\n  # Prepare data for display\n  display_data <- lexeme_data |>\n    select(settlement, value, stimuli, answer, collected) |>\n    arrange(settlement, value)\n  \n  # Use DT package for interactive table\n  DT::datatable(display_data, \n                class = \"cell-border stripe\",\n                rownames = FALSE,\n                filter = \"top\",\n                options = list(pageLength = 25, \n                             autoWidth = TRUE,\n                             info = FALSE))\n} else {\n  cat(\"Данные для этой лексемы недоступны.\\n\")\n}\n```\n\n:::\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":false,"number-sections":false,"self-contained":true,"css":["styles.css"],"output-file":"200_Ergative_stem_of_the_medial_demonstrative.html"},"language":{"toc-title-document":"Содержание","toc-title-website":"Содержание","related-formats-title":"Другие форматы","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Источник","other-links-title":"Другие ссылки","code-links-title":"Ссылки на код","launch-dev-container-title":"Запустить Dev Container","launch-binder-title":"Запустить Binder","article-notebook-label":"Блокнот статьи","notebook-preview-download":"Скачать блокнот","notebook-preview-download-src":"Скачать исходный код","notebook-preview-back":"Вернуться к статье","manuscript-meca-bundle":"Архив MECA","section-title-abstract":"Аннотация","section-title-appendices":"Приложения","section-title-footnotes":"Сноски","section-title-references":"использованная литература","section-title-reuse":"Повторное использование","section-title-copyright":"Авторские права","section-title-citation":"Цитата","appendix-attribution-cite-as":"Пожалуйста, цитируйте эту работу как:","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Просмотреть Лицензию","title-block-author-single":"Автор","title-block-author-plural":"Авторы","title-block-affiliation-single":"принадлежность","title-block-affiliation-plural":"Принадлежности","title-block-published":"Дата публикации","title-block-modified":"Файл изменен","title-block-keywords":"Ключевые слова","callout-tip-title":"Совет","callout-note-title":"Уведомление","callout-warning-title":"Предупреждение","callout-important-title":"Важное уведомление","callout-caution-title":"Осторожность","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Развернуть код","code-tools-hide-all-code":"Скрыть код","code-tools-view-source":"Показать код","code-tools-source-code":"Исходный код","tools-share":"Share","tools-download":"Download","code-line":"Линия","code-lines":"Линии","copy-button-tooltip":"Скопировать текст","copy-button-tooltip-success":"Скопировано","repo-action-links-edit":"Редактировать страницу","repo-action-links-source":"Показать код","repo-action-links-issue":"Сообщить о проблеме","back-to-top":"Наверх","search-no-results-text":"Поиск не дал результатов","search-matching-documents-text":"Результаты поиска","search-copy-link-title":"Скопировать ссылку","search-hide-matches-text":"Скрыть дополнительные результаты","search-more-match-text":"дополнительный результат в этом документе","search-more-matches-text":"дополнительных результата(-ов) в этом документе","search-clear-button-title":"Очистить","search-text-placeholder":"","search-detached-cancel-button-title":"Отменить","search-submit-button-title":"Найти","search-label":"Поиск","toggle-section":"Переключить раздел","toggle-sidebar":"Переключить боковую панель навигации","toggle-dark-mode":"Переключить темный режим","toggle-reader-mode":"Переключить режим чтения","toggle-navigation":"Переключить навигацию","crossref-fig-title":"Рисунок","crossref-tbl-title":"Таблица","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лемма","crossref-cor-title":"Следствие","crossref-prp-title":"Утверждение","crossref-cnj-title":"Гипотеза","crossref-def-title":"Определение","crossref-exm-title":"Пример","crossref-exr-title":"Упражнение","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Приложение","crossref-sec-prefix":"Глава","crossref-eq-prefix":"Уравнение","crossref-lof-title":"Список Иллюстраций","crossref-lot-title":"Список Таблиц","crossref-lol-title":"Список Каталогов","environment-proof-title":"Доказательство","environment-remark-title":"Примечание","environment-solution-title":"Решение","listing-page-order-by":"Сортировать по","listing-page-order-by-default":"предварительно выбранный","listing-page-order-by-date-asc":"Самый старый","listing-page-order-by-date-desc":"Новейшие","listing-page-order-by-number-desc":"нисходящий","listing-page-order-by-number-asc":"по возрастанию","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Описание","listing-page-field-author":"Автор","listing-page-field-filename":"Имя файла","listing-page-field-filemodified":"Файл изменен","listing-page-field-subtitle":"Подзаголовок","listing-page-field-readingtime":"Время чтения","listing-page-field-wordcount":"Подсчет слов","listing-page-field-categories":"Категории","listing-page-minutes-compact":"{0} минут","listing-page-category-all":"Все","listing-page-no-matches":"Нет подходящих элементов","listing-page-words":"{0} слов","listing-page-filter":"Фильтр","draft":"Черновик"},"metadata":{"lang":"ru","fig-responsive":true,"quarto-version":"1.7.33","theme":"litera","title":"Ergative stem of the medial demonstrative","author":"Maksim Melenchenko","date":"2025-08-28"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}