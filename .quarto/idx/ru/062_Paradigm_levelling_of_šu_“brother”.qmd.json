{"title":"Paradigm levelling of šu “brother”","markdown":{"yaml":{"title":"Paradigm levelling of šu “brother”","author":"Nikita Beklemishev","date":"2025-08-28","format":"html","lang":"ru","css":"styles.css"},"headingText":"‘brother’ /šu/, ‘brothers’ /šübe/","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 9.5)\n```\n\nUmlautization of the stem, e.g. applying the [+front, −back] features to the stem vowels, as a means of marking the PL forms appears not only in verbal stems (see phonology feature [@Vowel fronting in APL]). Something of similar nature is found in paradigm of the lexeme /šu/ ‘brother’ and a few other kin terms in some dialects. While the regular formation would be adding a -bɨr/-mar suffix, actually the suffix -bä (-be, bäˁ, bâ) is added. Moreover, the noun takes a special plural stem /šü/. [@filatovms §8.1 @danielfilatovms §1.3] This feature indicates whether the stem paradigm levells (and by plural or by singular form) or the alternation remains. Preliminary values are vowels in the first syllable of ‘brother.SG’ and the vowels of the first syllabe of ‘brother.PL’. The values u / uˁ in singular with ü / üˁ in plural are grouped together as **alternating** stem, values u / uˁ in both singular and plural are grouped as levelled by **SG stem**. Values where ü / üˁ occurs in both singular and plural are grouped as levelled by **PL stem**. Cases where ‘brother’ forms plural with the reglar affix are marked as **no irregularity**.\n\n\n\n::: {.panel-tabset}\n\n### Карта\n\n```{r}\n# Load data for this lexeme\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(lingtypology)\n\n# Read the database and villages data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\nvillages <- read_csv(\"../data/villages.csv\", show_col_types = FALSE)\n\n# Filter villages like in original script (exclude certain villages)\nvillages4map <- villages |>\n  filter(!(village %in% c(\"Kazankulak\", \"Novyy Borch\", \"Vrush\", \"Aran\", \"Khnyukh\")))\n\n# Create mapping data for this lexeme\nlexeme_data <- db |>\n  filter(feature_id == 62) |>  # First filter by feature_id\n  filter(feature_lexeme == \"‘brother’ /šu/, ‘brothers’ /šübe/\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {\n  # Create mapping data for this lexeme\n  mapping_data <- lexeme_data |>\n    mutate(value = str_split(value, \" ; \")) |>\n    unnest_longer(value) |>\n    distinct(settlement, value) |>\n    mutate(n = 1) |>\n    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>\n    left_join(villages4map[,c(\"village\",\"lat\",\"lon\")], by = c(\"settlement\" = \"village\")) |>\n    mutate(language = \"Rutul\") |>\n    filter(!is.na(lat) & !is.na(lon))\n\n  if (nrow(mapping_data) > 0) {\n    # Convert feature columns to numeric\n    feature_cols <- setdiff(colnames(mapping_data), c(\"settlement\",\"lat\",\"lon\",\"language\"))\n    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))\n\n    # Create sophisticated mapping approach with ALWAYS visible village names\n    if(length(feature_cols) == 1){\n      # single feature column - show all villages in gray, feature data in color\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE,\n                                width = 10,\n                                tile = \"OpenStreetMap.HOT\",\n                                features = feature_cols)\n\n      # Show both maps\n      base_map\n      feature_map\n    } else {\n      # multiple feature columns - use pie charts with ALWAYS visible village names\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                minichart.data = mapping_data |> select(all_of(feature_cols)),\n                                minichart = \"pie\",\n                                width = 3,\n                                tile = \"OpenStreetMap.HOT\",\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE)\n\n      # Show both maps\n      base_map\n      feature_map\n    }\n  } else {\n    cat(\"Географические координаты недоступны для картографирования.\\n\")\n  }\n} else {\n  cat(\"Данные для этой лексемы недоступны или координаты деревень не найдены.\\n\")\n}\n```\n\n### Данные\n\n```{r}\n# Load required libraries\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\n\n# Read the database data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\n\n# Create interactive table for this lexeme\nlexeme_data <- db |> \n  filter(feature_id == 62) |>  # First filter by feature_id\n  filter(feature_lexeme == \"‘brother’ /šu/, ‘brothers’ /šübe/\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0) {\n  # Prepare data for display\n  display_data <- lexeme_data |>\n    select(settlement, value, stimuli, answer, collected) |>\n    arrange(settlement, value)\n  \n  # Use DT package for interactive table\n  DT::datatable(display_data, \n                class = \"cell-border stripe\",\n                rownames = FALSE,\n                filter = \"top\",\n                options = list(pageLength = 25, \n                             autoWidth = TRUE,\n                             info = FALSE))\n} else {\n  cat(\"Данные для этой лексемы недоступны.\\n\")\n}\n```\n\n:::\n\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 9.5)\n```\n\nUmlautization of the stem, e.g. applying the [+front, −back] features to the stem vowels, as a means of marking the PL forms appears not only in verbal stems (see phonology feature [@Vowel fronting in APL]). Something of similar nature is found in paradigm of the lexeme /šu/ ‘brother’ and a few other kin terms in some dialects. While the regular formation would be adding a -bɨr/-mar suffix, actually the suffix -bä (-be, bäˁ, bâ) is added. Moreover, the noun takes a special plural stem /šü/. [@filatovms §8.1 @danielfilatovms §1.3] This feature indicates whether the stem paradigm levells (and by plural or by singular form) or the alternation remains. Preliminary values are vowels in the first syllable of ‘brother.SG’ and the vowels of the first syllabe of ‘brother.PL’. The values u / uˁ in singular with ü / üˁ in plural are grouped together as **alternating** stem, values u / uˁ in both singular and plural are grouped as levelled by **SG stem**. Values where ü / üˁ occurs in both singular and plural are grouped as levelled by **PL stem**. Cases where ‘brother’ forms plural with the reglar affix are marked as **no irregularity**.\n\n\n## ‘brother’ /šu/, ‘brothers’ /šübe/\n\n::: {.panel-tabset}\n\n### Карта\n\n```{r}\n# Load data for this lexeme\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(lingtypology)\n\n# Read the database and villages data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\nvillages <- read_csv(\"../data/villages.csv\", show_col_types = FALSE)\n\n# Filter villages like in original script (exclude certain villages)\nvillages4map <- villages |>\n  filter(!(village %in% c(\"Kazankulak\", \"Novyy Borch\", \"Vrush\", \"Aran\", \"Khnyukh\")))\n\n# Create mapping data for this lexeme\nlexeme_data <- db |>\n  filter(feature_id == 62) |>  # First filter by feature_id\n  filter(feature_lexeme == \"‘brother’ /šu/, ‘brothers’ /šübe/\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {\n  # Create mapping data for this lexeme\n  mapping_data <- lexeme_data |>\n    mutate(value = str_split(value, \" ; \")) |>\n    unnest_longer(value) |>\n    distinct(settlement, value) |>\n    mutate(n = 1) |>\n    pivot_wider(names_from = value, values_from = n, values_fill = 0) |>\n    left_join(villages4map[,c(\"village\",\"lat\",\"lon\")], by = c(\"settlement\" = \"village\")) |>\n    mutate(language = \"Rutul\") |>\n    filter(!is.na(lat) & !is.na(lon))\n\n  if (nrow(mapping_data) > 0) {\n    # Convert feature columns to numeric\n    feature_cols <- setdiff(colnames(mapping_data), c(\"settlement\",\"lat\",\"lon\",\"language\"))\n    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))\n\n    # Create sophisticated mapping approach with ALWAYS visible village names\n    if(length(feature_cols) == 1){\n      # single feature column - show all villages in gray, feature data in color\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE,\n                                width = 10,\n                                tile = \"OpenStreetMap.HOT\",\n                                features = feature_cols)\n\n      # Show both maps\n      base_map\n      feature_map\n    } else {\n      # multiple feature columns - use pie charts with ALWAYS visible village names\n      base_map <- map.feature(languages = \"Rutul\",\n                             latitude = villages4map$lat,\n                             longitude = villages4map$lon,\n                             label = villages4map$village,\n                             label.position = \"top\",\n                             label.hide = FALSE,\n                             width = 10,\n                             color = \"gray\",\n                             tile = \"OpenStreetMap.HOT\",\n                             opacity = 0.4)\n\n      feature_map <- map.feature(languages = \"Rutul\",\n                                latitude = mapping_data$lat,\n                                longitude = mapping_data$lon,\n                                minichart.data = mapping_data |> select(all_of(feature_cols)),\n                                minichart = \"pie\",\n                                width = 3,\n                                tile = \"OpenStreetMap.HOT\",\n                                label = mapping_data$settlement,\n                                label.position = \"top\",\n                                label.hide = FALSE)\n\n      # Show both maps\n      base_map\n      feature_map\n    }\n  } else {\n    cat(\"Географические координаты недоступны для картографирования.\\n\")\n  }\n} else {\n  cat(\"Данные для этой лексемы недоступны или координаты деревень не найдены.\\n\")\n}\n```\n\n### Данные\n\n```{r}\n# Load required libraries\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\n\n# Read the database data\ndb <- read_csv(\"../data/database.csv\", show_col_types = FALSE)\n\n# Create interactive table for this lexeme\nlexeme_data <- db |> \n  filter(feature_id == 62) |>  # First filter by feature_id\n  filter(feature_lexeme == \"‘brother’ /šu/, ‘brothers’ /šübe/\") |>  # Then filter by feature_lexeme\n  filter(!is.na(value), value != \"NO DATA\")\n\nif (nrow(lexeme_data) > 0) {\n  # Prepare data for display\n  display_data <- lexeme_data |>\n    select(settlement, value, stimuli, answer, collected) |>\n    arrange(settlement, value)\n  \n  # Use DT package for interactive table\n  DT::datatable(display_data, \n                class = \"cell-border stripe\",\n                rownames = FALSE,\n                filter = \"top\",\n                options = list(pageLength = 25, \n                             autoWidth = TRUE,\n                             info = FALSE))\n} else {\n  cat(\"Данные для этой лексемы недоступны.\\n\")\n}\n```\n\n:::\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":false,"number-sections":false,"self-contained":true,"css":["styles.css"],"output-file":"062_Paradigm_levelling_of_šu_“brother”.html"},"language":{"toc-title-document":"Содержание","toc-title-website":"Содержание","related-formats-title":"Другие форматы","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Источник","other-links-title":"Другие ссылки","code-links-title":"Ссылки на код","launch-dev-container-title":"Запустить Dev Container","launch-binder-title":"Запустить Binder","article-notebook-label":"Блокнот статьи","notebook-preview-download":"Скачать блокнот","notebook-preview-download-src":"Скачать исходный код","notebook-preview-back":"Вернуться к статье","manuscript-meca-bundle":"Архив MECA","section-title-abstract":"Аннотация","section-title-appendices":"Приложения","section-title-footnotes":"Сноски","section-title-references":"использованная литература","section-title-reuse":"Повторное использование","section-title-copyright":"Авторские права","section-title-citation":"Цитата","appendix-attribution-cite-as":"Пожалуйста, цитируйте эту работу как:","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Просмотреть Лицензию","title-block-author-single":"Автор","title-block-author-plural":"Авторы","title-block-affiliation-single":"принадлежность","title-block-affiliation-plural":"Принадлежности","title-block-published":"Дата публикации","title-block-modified":"Файл изменен","title-block-keywords":"Ключевые слова","callout-tip-title":"Совет","callout-note-title":"Уведомление","callout-warning-title":"Предупреждение","callout-important-title":"Важное уведомление","callout-caution-title":"Осторожность","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Развернуть код","code-tools-hide-all-code":"Скрыть код","code-tools-view-source":"Показать код","code-tools-source-code":"Исходный код","tools-share":"Share","tools-download":"Download","code-line":"Линия","code-lines":"Линии","copy-button-tooltip":"Скопировать текст","copy-button-tooltip-success":"Скопировано","repo-action-links-edit":"Редактировать страницу","repo-action-links-source":"Показать код","repo-action-links-issue":"Сообщить о проблеме","back-to-top":"Наверх","search-no-results-text":"Поиск не дал результатов","search-matching-documents-text":"Результаты поиска","search-copy-link-title":"Скопировать ссылку","search-hide-matches-text":"Скрыть дополнительные результаты","search-more-match-text":"дополнительный результат в этом документе","search-more-matches-text":"дополнительных результата(-ов) в этом документе","search-clear-button-title":"Очистить","search-text-placeholder":"","search-detached-cancel-button-title":"Отменить","search-submit-button-title":"Найти","search-label":"Поиск","toggle-section":"Переключить раздел","toggle-sidebar":"Переключить боковую панель навигации","toggle-dark-mode":"Переключить темный режим","toggle-reader-mode":"Переключить режим чтения","toggle-navigation":"Переключить навигацию","crossref-fig-title":"Рисунок","crossref-tbl-title":"Таблица","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лемма","crossref-cor-title":"Следствие","crossref-prp-title":"Утверждение","crossref-cnj-title":"Гипотеза","crossref-def-title":"Определение","crossref-exm-title":"Пример","crossref-exr-title":"Упражнение","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Приложение","crossref-sec-prefix":"Глава","crossref-eq-prefix":"Уравнение","crossref-lof-title":"Список Иллюстраций","crossref-lot-title":"Список Таблиц","crossref-lol-title":"Список Каталогов","environment-proof-title":"Доказательство","environment-remark-title":"Примечание","environment-solution-title":"Решение","listing-page-order-by":"Сортировать по","listing-page-order-by-default":"предварительно выбранный","listing-page-order-by-date-asc":"Самый старый","listing-page-order-by-date-desc":"Новейшие","listing-page-order-by-number-desc":"нисходящий","listing-page-order-by-number-asc":"по возрастанию","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Описание","listing-page-field-author":"Автор","listing-page-field-filename":"Имя файла","listing-page-field-filemodified":"Файл изменен","listing-page-field-subtitle":"Подзаголовок","listing-page-field-readingtime":"Время чтения","listing-page-field-wordcount":"Подсчет слов","listing-page-field-categories":"Категории","listing-page-minutes-compact":"{0} минут","listing-page-category-all":"Все","listing-page-no-matches":"Нет подходящих элементов","listing-page-words":"{0} слов","listing-page-filter":"Фильтр","draft":"Черновик"},"metadata":{"lang":"ru","fig-responsive":true,"quarto-version":"1.7.33","theme":"litera","title":"Paradigm levelling of šu “brother”","author":"Nikita Beklemishev","date":"2025-08-28"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}