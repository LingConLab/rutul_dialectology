---
title: "Meditative polar question"
author: "Timur Maisak"
date: 2025-08-28
format: html
css: styles.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 9.5)
```

Meditative questions are questions that do not require an answer from the addressee; often, such questions are self-addressed. In Rutul, special verb forms or special clitic markers are often used in meditative questions. In meditative polar questions, a special marker is a dedicated suffix on the verb form, which may follow a dedicated polar interrogative marker (-m, -ma, -me). An additional specialized marker used in meditative polar question can be the same as found in meditative content questions and has an initial consonant /d/ or /t/. Besides, an additional specialized marker can have the form -jixʲ / -xʲ / -kʲ / -j etc., which ultimately goes back to the imperative of the verb “say“ (jixʲ).


## Feature Map

::: {.panel-tabset}

### Map

```{r}
# Load data for this feature
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(lingtypology)

# Read the database and villages data
db <- read_csv("data/database.csv", show_col_types = FALSE)
villages <- read_csv("data/villages.csv", show_col_types = FALSE)

# Filter villages like in original script (exclude certain villages)
villages4map <- villages |> 
  filter(!(village %in% c("Kazankulak", "Novyy Borch", "Vrush", "Aran", "Khnyukh")))

# Create mapping data for this feature
feature_data <- db |> 
  filter(feature_id == 144) |>  # Filter by feature_id
  filter(!is.na(value), value != "NO DATA")

if (nrow(feature_data) > 0 && nrow(villages4map) > 0) {
  # Create mapping data for this feature
  mapping_data <- feature_data |>
    mutate(value = str_split(value, " ; ")) |> 
    unnest_longer(value) |> 
    distinct(settlement, value) |> 
    mutate(n = 1) |> 
    pivot_wider(names_from = value, values_from = n, values_fill = 0) |> 
    left_join(villages4map[,c("village","lat","lon")], by = c("settlement" = "village")) |> 
    mutate(language = "Rutul") |>
    filter(!is.na(lat) & !is.na(lon))
  
  if (nrow(mapping_data) > 0) {
    # Convert feature columns to numeric
    feature_cols <- setdiff(colnames(mapping_data), c("settlement","lat","lon","language"))
    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))
    
    # Create sophisticated mapping approach with ALWAYS visible village names
    if(length(feature_cols) == 1){
      # single feature column - show all villages in gray, feature data in color
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)
      
      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE,
                                width = 10,
                                tile = "OpenStreetMap.HOT",
                                features = feature_cols)
      
      # Show both maps
      base_map
      feature_map
    } else {
      # multiple feature columns - use pie charts with ALWAYS visible village names
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)
      
      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                minichart.data = mapping_data |> select(all_of(feature_cols)),
                                minichart = "pie",
                                width = 3,
                                tile = "OpenStreetMap.HOT",
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE)
      
      # Show both maps
      base_map
      feature_map
    }
  } else {
    cat("No geographical coordinates available for mapping.\n")
  }
} else {
  cat("No data available for this feature or no village coordinates found.\n")
}
```

### Data

```{r}
# Load required libraries
library(readr)
library(dplyr)
library(DT)

# Read the database data
db <- read_csv("data/database.csv", show_col_types = FALSE)

# Create interactive table for this feature
feature_data <- db |> 
  filter(feature_id == 144) |>  # Filter by feature_id
  filter(!is.na(value), value != "NO DATA")

if (nrow(feature_data) > 0) {
  # Prepare data for display
  display_data <- feature_data |>
    select(settlement, value, stimuli, answer, collected) |>
    arrange(settlement, value)
  
  # Use DT package for interactive table
  DT::datatable(display_data, 
                class = "cell-border stripe",
                rownames = FALSE,
                filter = "top",
                options = list(pageLength = 25, 
                             autoWidth = TRUE,
                             info = FALSE))
} else {
  cat("No data available for this feature.\n")
}
```

:::

