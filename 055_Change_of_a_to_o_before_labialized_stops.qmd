---
title: "Change of a to o before labialized stops"
author: "Nikita Beklemishev"
date: 2025-08-28
format: html
css: styles.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 9.5)
```

In a simple rule, some dialects are expected to have an a > o / \_[+cons, +round] phonetic alternation or sound change. By this rule, /a/ is rounded before a labialized consonant. In practice, we diagnose this by asking for cognates of two Kina word forms (which find a cognate in most dialects): /ʁagʷas/ ‘to see’ and /maɢːʷal/ ‘nettle’. The sounds in check (preliminary values) are the vowels in the first syllable and the consonants after it. In final values, values aw / äCʷ / eCʷ / and cognate not given (N/A) are grouped together as not matching the sample, marked as OTHER, values agʷ / aɢʷ / aɢːʷ / aqʷ are grouped together as having the sound [a], and values ogʷ / oɢʷ as having [o]. It’s important to note that I don’t know enough to interpret the phonological nature of the combinations. I consider only labialization in the surface form: regardless of whether it is intrinsic or due to proximity to a rounded vowel. Same applies for o ~ a alternation: we can’t assume whether the distinction has been phonologised or it is a surface-level alternation.


## ‘nettle’ /maɢːʷal/

::: {.panel-tabset}

### Map

```{r}
# Load data for this lexeme
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(lingtypology)

# Read the database and villages data
db <- read_csv("data/database.csv", show_col_types = FALSE)
villages <- read_csv("data/villages.csv", show_col_types = FALSE)

# Filter villages like in original script (exclude certain villages)
villages4map <- villages |> 
  filter(!(village %in% c("Kazankulak", "Novyy Borch", "Vrush", "Aran", "Khnyukh")))

# Create mapping data for this lexeme
lexeme_data <- db |> 
  filter(feature_id == 55) |>  # First filter by feature_id
  filter(feature_lexeme == "‘nettle’ /maɢːʷal/") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {
  # Create mapping data for this lexeme
  mapping_data <- lexeme_data |>
    mutate(value = str_split(value, " ; ")) |> 
    unnest_longer(value) |> 
    distinct(settlement, value) |> 
    mutate(n = 1) |> 
    pivot_wider(names_from = value, values_from = n, values_fill = 0) |> 
    left_join(villages4map[,c("village","lat","lon")], by = c("settlement" = "village")) |> 
    mutate(language = "Rutul") |>
    filter(!is.na(lat) & !is.na(lon))
  
  if (nrow(mapping_data) > 0) {
    # Convert feature columns to numeric
    feature_cols <- setdiff(colnames(mapping_data), c("settlement","lat","lon","language"))
    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))
    
    # Create sophisticated mapping approach with ALWAYS visible village names
    if(length(feature_cols) == 1){
      # single feature column - show all villages in gray, feature data in color
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)
      
      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE,
                                width = 10,
                                tile = "OpenStreetMap.HOT",
                                features = feature_cols)
      
      # Show both maps
      base_map
      feature_map
    } else {
      # multiple feature columns - use pie charts with ALWAYS visible village names
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)
      
      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                minichart.data = mapping_data |> select(all_of(feature_cols)),
                                minichart = "pie",
                                width = 3,
                                tile = "OpenStreetMap.HOT",
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE)
      
      # Show both maps
      base_map
      feature_map
    }
  } else {
    cat("No geographical coordinates available for mapping.\n")
  }
} else {
  cat("No data available for this lexeme or no village coordinates found.\n")
}
```

### Data

```{r}
# Load required libraries
library(readr)
library(dplyr)
library(DT)

# Read the database data
db <- read_csv("data/database.csv", show_col_types = FALSE)

# Create interactive table for this lexeme
lexeme_data <- db |> 
  filter(feature_id == 55) |>  # First filter by feature_id
  filter(feature_lexeme == "‘nettle’ /maɢːʷal/") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0) {
  # Prepare data for display
  display_data <- lexeme_data |>
    select(settlement, value, stimuli, answer, collected) |>
    arrange(settlement, value)
  
  # Use DT package for interactive table
  DT::datatable(display_data, 
                class = "cell-border stripe",
                rownames = FALSE,
                filter = "top",
                options = list(pageLength = 25, 
                             autoWidth = TRUE,
                             info = FALSE))
} else {
  cat("No data available for this lexeme.\n")
}
```

:::

## ‘to see’ /ʁagʷas/

::: {.panel-tabset}

### Map

```{r}
# Load data for this lexeme
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(lingtypology)

# Read the database and villages data
db <- read_csv("data/database.csv", show_col_types = FALSE)
villages <- read_csv("data/villages.csv", show_col_types = FALSE)

# Filter villages like in original script (exclude certain villages)
villages4map <- villages |> 
  filter(!(village %in% c("Kazankulak", "Novyy Borch", "Vrush", "Aran", "Khnyukh")))

# Create mapping data for this lexeme
lexeme_data <- db |> 
  filter(feature_id == 55) |>  # First filter by feature_id
  filter(feature_lexeme == "‘to see’ /ʁagʷas/") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0 && nrow(villages4map) > 0) {
  # Create mapping data for this lexeme
  mapping_data <- lexeme_data |>
    mutate(value = str_split(value, " ; ")) |> 
    unnest_longer(value) |> 
    distinct(settlement, value) |> 
    mutate(n = 1) |> 
    pivot_wider(names_from = value, values_from = n, values_fill = 0) |> 
    left_join(villages4map[,c("village","lat","lon")], by = c("settlement" = "village")) |> 
    mutate(language = "Rutul") |>
    filter(!is.na(lat) & !is.na(lon))
  
  if (nrow(mapping_data) > 0) {
    # Convert feature columns to numeric
    feature_cols <- setdiff(colnames(mapping_data), c("settlement","lat","lon","language"))
    mapping_data <- mapping_data |> mutate(across(all_of(feature_cols), as.numeric))
    
    # Create sophisticated mapping approach with ALWAYS visible village names
    if(length(feature_cols) == 1){
      # single feature column - show all villages in gray, feature data in color
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)
      
      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE,
                                width = 10,
                                tile = "OpenStreetMap.HOT",
                                features = feature_cols)
      
      # Show both maps
      base_map
      feature_map
    } else {
      # multiple feature columns - use pie charts with ALWAYS visible village names
      base_map <- map.feature(languages = "Rutul",
                             latitude = villages4map$lat,
                             longitude = villages4map$lon,
                             label = villages4map$village,
                             label.position = "top",
                             label.hide = FALSE,
                             width = 10,
                             color = "gray",
                             tile = "OpenStreetMap.HOT",
                             opacity = 0.4)
      
      feature_map <- map.feature(languages = "Rutul",
                                latitude = mapping_data$lat,
                                longitude = mapping_data$lon,
                                minichart.data = mapping_data |> select(all_of(feature_cols)),
                                minichart = "pie",
                                width = 3,
                                tile = "OpenStreetMap.HOT",
                                label = mapping_data$settlement,
                                label.position = "top",
                                label.hide = FALSE)
      
      # Show both maps
      base_map
      feature_map
    }
  } else {
    cat("No geographical coordinates available for mapping.\n")
  }
} else {
  cat("No data available for this lexeme or no village coordinates found.\n")
}
```

### Data

```{r}
# Load required libraries
library(readr)
library(dplyr)
library(DT)

# Read the database data
db <- read_csv("data/database.csv", show_col_types = FALSE)

# Create interactive table for this lexeme
lexeme_data <- db |> 
  filter(feature_id == 55) |>  # First filter by feature_id
  filter(feature_lexeme == "‘to see’ /ʁagʷas/") |>  # Then filter by feature_lexeme
  filter(!is.na(value), value != "NO DATA")

if (nrow(lexeme_data) > 0) {
  # Prepare data for display
  display_data <- lexeme_data |>
    select(settlement, value, stimuli, answer, collected) |>
    arrange(settlement, value)
  
  # Use DT package for interactive table
  DT::datatable(display_data, 
                class = "cell-border stripe",
                rownames = FALSE,
                filter = "top",
                options = list(pageLength = 25, 
                             autoWidth = TRUE,
                             info = FALSE))
} else {
  cat("No data available for this lexeme.\n")
}
```

:::

